global !p

# python tex environments
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def comment(): 
	return vim.eval('vimtex#syntax#in_comment()') == '1'
endglobal


# package
snippet pac "Package" bA
\\usepackage[${1:options}]{${2:packages}}$0
endsnippet


# skips
snippet ;ss "\smallskip" bA
\\smallskip$0
endsnippet

snippet ;ms "\medskip" bA
\\medskip$0
endsnippet

snippet ;bs "\bigskip" bA
\\bigskip$0
endsnippet


# indentation
snippet ;ni "\noindent" bA
\\noindent$0
endsnippet


# begin - end textmode
snippet beg "\begin{$} \\ \end{$}" bA
\\begin{$1}$2
$0
\\end{$1}
endsnippet

snippet enum "\begin{enumerate} \\ \end{enumerate}" bA
\\begin{enumerate}
	\\item $0
\\end{enumerate}
endsnippet

snippet item "\begin{itemize} \\ \end{itemize}" bA
\\begin{itemize}
	\\item $0
\\end{itemize}
endsnippet


# math environment
snippet mk "Inline math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet dm "Display math" wA
\[
${1:${VISUAL}}
.\] $0
endsnippet

snippet ali "Align" bA
\begin{align*}
	${1:${VISUAL}}
.\end{align*}
endsnippet

context "math()"
snippet case "cases" wA
\begin{cases}
	$1
\end{cases}
endsnippet


# math arrows
priority 10
snippet => "implies" Ai
\implies
endsnippet

snippet =< "implied by" Ai
\impliedby
endsnippet

priority 20
context "math()"
snippet <=> "\Leftrightarrow" iA
\Leftrightarrow
endsnippet
priority 0


# math brackets
context "math()"
snippet () "left($right)" iA
\left(${1:${VISUAL}}\right)$0
endsnippet

context "math()"
snippet lr "left($right)" i
\left(${1:${VISUAL}}\right)$0
endsnippet

context "math()"
snippet lr( "left($right)" i
\left(${1:${VISUAL}}\right)$0
endsnippet

context "math()"
snippet lr{ "left\{$right\}" i
\left\\{${1:${VISUAL}}\right\\}$0
endsnippet

context "math()"
snippet lr[ "left[$right]" i
\left[${1:${VISUAL}}\right]$0
endsnippet

context "math()"
snippet lr| "left|$right|" i
\left|${1:${VISUAL}}\right|$0
endsnippet


# math denotations
context "math()"
snippet tt "text" iA
\text{$1}$0
endsnippet

context "math()"
snippet bar "\overline{$}" iA
\overline{$1}
endsnippet

context "math()"
snippet td "to the ... power" iA
^{$1}$0
endsnippet

snippet __ "subscript" iA
_{$1}$0
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript 2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet


# math fractions
context "math()"
snippet / "\frac{$V}{$}" i
\\frac{${VISUAL}}{$1}$0
endsnippet

context "math()"
snippet '^.*\)/' "() frac" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "symbol frac" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet


# math diff
snippet part "d/dx" w
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet


# math operations
priority 10
context "math()"
snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|perp)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

priority 20
context "math()"
snippet '(?<!\\)(arcsin|arccos|arctan|arccot|arccsc|arcsec|pi|zeta|int)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet
priority 0

context "math()"
snippet lim "\lim_{}" w
\lim_{${1:n} \to ${2:\infty}}$0 
endsnippet

context "math()"
snippet infty "\infty" iA
\infty
endsnippet

priority 10
context "math()"
snippet -> "\to" iA
\to 
endsnippet

priority 20
context "math()"
snippet <-> "\leftrightarrow" iA
\leftrightarrow
endsnippet
priority 0

context "math()"
snippet ** "cdot" iA
\cdot 
endsnippet

context "math()"
snippet dint "integral" wA
\int_{${1:-\infty}}^{${2:+\infty}} ${3:${VISUAL}} $0
endsnippet

context "math()"
snippet abs "norm" iA
\|$1\|$0
endsnippet

context "math()"
snippet sq "\sqrt{}" iA
\sqrt{${1:${VISUAL}}} $0
endsnippet

snippet sum "sum" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n z^n}
endsnippet

context "math()"
snippet ceil "ceil" iA
\left\lceil $1 \right\rceil $0
endsnippet

context "math()"
snippet floor "floor" iA
\left\lfloor $1 \right\rfloor$0
endsnippet


# math signs
snippet != "\neq" iA
\neq 
endsnippet

snippet <= "\le" iA
\le 
endsnippet

snippet >= "\ge" iA
\ge 
endsnippet

snippet == "equals" iA
&= $1 \\\\
endsnippet


# math sets
context "math()"
snippet set "set" wA
\\{$1\\} $0
endsnippet


# math set variables
snippet NN "n" iA
\N
endsnippet

snippet OO "emptyset" iA
\O
endsnippet

snippet RR "real" iA
\R
endsnippet

snippet QQ "Q" iA
\Q
endsnippet

snippet ZZ "Z" iA
\Z
endsnippet

# math set operations
context "math()"
snippet xx "cross" iA
\times 
endsnippet

context "math()"
snippet inn "\in" iA
\in
endsnippet

context "math()"
snippet nin "\not\in" iA
\not\in
endsnippet

context "math()"
snippet ss "\subset" iA
\subset
endsnippet

context "math()"
snippet sm "\setminus" iA
\setminus
endsnippet

snippet Nn "cap" iA
\cap 
endsnippet

snippet UU "cup" iA
\cup 
endsnippet

snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet


# math logic signs
context "math()"
snippet EE "exists" iA
\exists 
endsnippet

context "math()"
snippet AA "forall" iA
\forall 
endsnippet


# new



# Comments (ADVANCED SNIPPETS) {{{ 
# -----------------------------------------------------------------------------
# ADVANCED 

# 4.10 Snippet actions - arbitrary python code can be executes: pre-expend(after trigger condition
# has been matches, but before snippet expansion, post-expand(after expansion,but before
# the first jump), jump - after jump to the next/previous placeholder.

# 4.07 Transformations (like mirrors, but can modify the mathced pattern)

# 4.09 Custom context snippets - can be enabled by 'e' (special conditions or switch)

# 4.4.4 Global snippets - !p and putting them in another file

##}}}


# vim: set foldmethod=marker foldlevel=0:
